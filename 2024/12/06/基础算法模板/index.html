
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>基础算法模板 | SWe1L</title>
    <meta name="author" content="Mr-SW" />
    <meta name="description" content="Hi!这是阿伟先生的个人博客，我会在这里分享我的刷题心得，还会分享一些生活趣事" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/a.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>SWE1L</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文档</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;SWE1L</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">文档</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>基础算法模板</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/6
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E9%98%BF%E4%BC%9F/" style="color: #ffa2c4">
                    阿伟
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" style="color: #00a596">
                    基础算法
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="常用代码模板1——基础算法"><a href="#常用代码模板1——基础算法" class="headerlink" title="常用代码模板1——基础算法"></a>常用代码模板1——基础算法</h1><h2 id="1-快速排序算法模板-——-模板题-AcWing-785-快速排序"><a href="#1-快速排序算法模板-——-模板题-AcWing-785-快速排序" class="headerlink" title="1.快速排序算法模板 —— 模板题 AcWing 785. 快速排序"></a>1.快速排序算法模板 —— 模板题 AcWing 785. 快速排序</h2><pre><code class="c++">void quick_sort(int q[], int l, int r)
&#123;
    if (l &gt;= r) return;

    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];
    while (i &lt; j)
    &#123;
        do i ++ ; while (q[i] &lt; x);
        do j -- ; while (q[j] &gt; x);
        if (i &lt; j) swap(q[i], q[j]);
    &#125;
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
&#125;
</code></pre>
<h2 id="2-归并排序算法模板-——-模板题-AcWing-787-归并排序"><a href="#2-归并排序算法模板-——-模板题-AcWing-787-归并排序" class="headerlink" title="2.归并排序算法模板 —— 模板题 AcWing 787. 归并排序"></a>2.归并排序算法模板 —— 模板题 AcWing 787. 归并排序</h2><pre><code class="c++">void merge_sort(int q[], int l, int r)
&#123;
    if (l &gt;= r) return;

    int mid = l + r &gt;&gt; 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= r)
        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];
    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];
&#125;
</code></pre>
<h2 id="3-整数二分算法模板-——-模板题-AcWing-789-数的范围"><a href="#3-整数二分算法模板-——-模板题-AcWing-789-数的范围" class="headerlink" title="3.整数二分算法模板 —— 模板题 AcWing 789. 数的范围"></a>3.整数二分算法模板 —— 模板题 AcWing 789. 数的范围</h2><pre><code class="c++">bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
&#123;
    while (l &lt; r)
    &#123;
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    &#125;
    return l;
&#125;
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
&#123;
    while (l &lt; r)
    &#123;
        int mid = l + r + 1 &gt;&gt; 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    &#125;
    return l;
&#125;
</code></pre>
<h2 id="4-浮点数二分算法模板-——-模板题-AcWing-790-数的三次方根"><a href="#4-浮点数二分算法模板-——-模板题-AcWing-790-数的三次方根" class="headerlink" title="4.浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根"></a>4.浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根</h2><pre><code class="c++">bool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质

double bsearch_3(double l, double r)
&#123;
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l &gt; eps)
    &#123;
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    &#125;
    return l;
&#125;
</code></pre>
<h2 id="5-高精度加法-——-模板题-AcWing-791-高精度加法"><a href="#5-高精度加法-——-模板题-AcWing-791-高精度加法" class="headerlink" title="5.高精度加法 —— 模板题 AcWing 791. 高精度加法"></a>5.高精度加法 —— 模板题 AcWing 791. 高精度加法</h2><pre><code class="c++">// C = A + B, A &gt;= 0, B &gt;= 0
vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
&#123;
    if (A.size() &lt; B.size()) return add(B, A);

    vector&lt;int&gt; C;
    int t = 0;
    for (int i = 0; i &lt; A.size(); i ++ )
    &#123;
        t += A[i];
        if (i &lt; B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    &#125;

    if (t) C.push_back(t);
    return C;
&#125;
</code></pre>
<h2 id="6-高精度减法-——-模板题-AcWing-792-高精度减法"><a href="#6-高精度减法-——-模板题-AcWing-792-高精度减法" class="headerlink" title="6.高精度减法 —— 模板题 AcWing 792. 高精度减法"></a>6.高精度减法 —— 模板题 AcWing 792. 高精度减法</h2><pre><code class="c++">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0
vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
&#123;
    vector&lt;int&gt; C;
    for (int i = 0, t = 0; i &lt; A.size(); i ++ )
    &#123;
        t = A[i] - t;
        if (i &lt; B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t &lt; 0) t = 1;
        else t = 0;
    &#125;

    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
&#125;
</code></pre>
<h2 id="7-高精度乘低精度-——-模板题-AcWing-793-高精度乘法"><a href="#7-高精度乘低精度-——-模板题-AcWing-793-高精度乘法" class="headerlink" title="7.高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法"></a>7.高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法</h2><pre><code class="c++">// C = A * b, A &gt;= 0, b &gt;= 0
vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)
&#123;
    vector&lt;int&gt; C;

    int t = 0;
    for (int i = 0; i &lt; A.size() || t; i ++ )
    &#123;
        if (i &lt; A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    &#125;

    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();

    return C;
&#125;
</code></pre>
<h2 id="8-高精度除以低精度-——-模板题-AcWing-794-高精度除法"><a href="#8-高精度除以低精度-——-模板题-AcWing-794-高精度除法" class="headerlink" title="8.高精度除以低精度 —— 模板题 AcWing 794. 高精度除法"></a>8.高精度除以低精度 —— 模板题 AcWing 794. 高精度除法</h2><pre><code class="c++">// A / b = C ... r, A &gt;= 0, b &gt; 0
vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)
&#123;
    vector&lt;int&gt; C;
    r = 0;
    for (int i = A.size() - 1; i &gt;= 0; i -- )
    &#123;
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    &#125;
    reverse(C.begin(), C.end());
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
&#125;
</code></pre>
<h2 id="9-前缀和"><a href="#9-前缀和" class="headerlink" title="9.前缀和"></a>9.前缀和</h2><p>​	一维前缀和 —— 模板题 AcWing 795. 前缀和</p>
<pre><code class="c++">S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
</code></pre>
<p>​	二维前缀和 —— 模板题 AcWing 796. 子矩阵的和</p>
<pre><code class="c++">S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
</code></pre>
<h2 id="10-差分"><a href="#10-差分" class="headerlink" title="10.差分"></a>10.差分</h2><p>​	一维差分 —— 模板题 AcWing 797. 差分</p>
<pre><code class="c++">给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
</code></pre>
<p>​	二维差分 —— 模板题 AcWing 798. 差分矩阵</p>
<pre><code class="c++">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
</code></pre>
<h2 id="11-位运算-——-模板题-AcWing-801-二进制中1的个数"><a href="#11-位运算-——-模板题-AcWing-801-二进制中1的个数" class="headerlink" title="11.位运算 —— 模板题 AcWing 801. 二进制中1的个数"></a>11.位运算 —— 模板题 AcWing 801. 二进制中1的个数</h2><pre><code class="c++">求n的第k位数字: n &gt;&gt; k &amp; 1
返回n的最后一位1：lowbit(n) = n &amp; -n
</code></pre>
<h2 id="12-双指针算法-——-模板题-AcWIng-799-最长连续不重复子序列-AcWing-800-数组元素的目标和"><a href="#12-双指针算法-——-模板题-AcWIng-799-最长连续不重复子序列-AcWing-800-数组元素的目标和" class="headerlink" title="12.双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和"></a>12.双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和</h2><pre><code class="c++">for (int i = 0, j = 0; i &lt; n; i ++ )
&#123;
    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;

    // 具体问题的逻辑
&#125;
</code></pre>
<p>​	常见问题分类：</p>
<ul>
<li><p>对于一个序列，用两个指针维护一段区间</p>
</li>
<li><p>对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p>
</li>
</ul>
<h2 id="13-离散化-——-模板题-AcWing-802-区间和"><a href="#13-离散化-——-模板题-AcWing-802-区间和" class="headerlink" title="13.离散化 —— 模板题 AcWing 802. 区间和"></a>13.离散化 —— 模板题 AcWing 802. 区间和</h2><pre><code class="c++">vector&lt;int&gt; alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
&#123;
    int l = 0, r = alls.size() - 1;
    while (l &lt; r)
    &#123;
        int mid = l + r &gt;&gt; 1;
        if (alls[mid] &gt;= x) r = mid;
        else l = mid + 1;
    &#125;
    return r + 1; // 映射到1, 2, ...n
&#125;
</code></pre>
<h2 id="14-区间合并-——-模板题-AcWing-803-区间合并"><a href="#14-区间合并-——-模板题-AcWing-803-区间合并" class="headerlink" title="14.区间合并 —— 模板题 AcWing 803. 区间合并"></a>14.区间合并 —— 模板题 AcWing 803. 区间合并</h2><pre><code class="c++">// 将所有存在交集的区间合并
void merge(vector&lt;PII&gt; &amp;segs)
&#123;
    vector&lt;PII&gt; res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed &lt; seg.first)
        &#123;
            if (st != -2e9) res.push_back(&#123;st, ed&#125;);
            st = seg.first, ed = seg.second;
        &#125;
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back(&#123;st, ed&#125;);

    segs = res;
&#125;
</code></pre>
<h1 id="常用代码模板2——数据结构"><a href="#常用代码模板2——数据结构" class="headerlink" title="常用代码模板2——数据结构"></a>常用代码模板2——数据结构</h1><h2 id="1-单链表-——-模板题-AcWing-826-单链表"><a href="#1-单链表-——-模板题-AcWing-826-单链表" class="headerlink" title="1.单链表 —— 模板题 AcWing 826. 单链表"></a>1.单链表 —— 模板题 AcWing 826. 单链表</h2><pre><code class="c++">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
&#123;
    head = -1;
    idx = 0;
&#125;

// 在链表头插入一个数a
void insert(int a)
&#123;
    e[idx] = a, ne[idx] = head, head = idx ++ ;
&#125;

// 将头结点删除，需要保证头结点存在
void remove()
&#123;
    head = ne[head];
&#125;
</code></pre>
<h2 id="2-双链表-——-模板题-AcWing-827-双链表"><a href="#2-双链表-——-模板题-AcWing-827-双链表" class="headerlink" title="2.双链表 —— 模板题 AcWing 827. 双链表"></a>2.双链表 —— 模板题 AcWing 827. 双链表</h2><pre><code class="c++">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
&#123;
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
&#125;

// 在节点a的右边插入一个数x
void insert(int a, int x)
&#123;
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
&#125;

// 删除节点a
void remove(int a)
&#123;
    l[r[a]] = l[a];
    r[l[a]] = r[a];
&#125;
</code></pre>
<h2 id="3-栈-——-模板题-AcWing-828-模拟栈"><a href="#3-栈-——-模板题-AcWing-828-模拟栈" class="headerlink" title="3.栈 —— 模板题 AcWing 828. 模拟栈"></a>3.栈 —— 模板题 AcWing 828. 模拟栈</h2><pre><code class="c++">// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空，如果 tt &gt; 0，则表示不为空
if (tt &gt; 0)
&#123;

&#125;
</code></pre>
<h2 id="4-队列-——-模板题-AcWing-829-模拟队列"><a href="#4-队列-——-模板题-AcWing-829-模拟队列" class="headerlink" title="4.队列 —— 模板题 AcWing 829. 模拟队列"></a>4.队列 —— 模板题 AcWing 829. 模拟队列</h2><h3 id="普通队列："><a href="#普通队列：" class="headerlink" title="普通队列："></a>普通队列：</h3><pre><code class="c++">// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空
if (hh &lt;= tt)
&#123;

&#125;
</code></pre>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><pre><code class="c++">// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空，如果hh != tt，则表示不为空
if (hh != tt)
&#123;

&#125;
</code></pre>
<h2 id="5-单调栈-——-模板题-AcWing-830-单调栈-常见模型：找出每个数左边离它最近的比它大-小的数"><a href="#5-单调栈-——-模板题-AcWing-830-单调栈-常见模型：找出每个数左边离它最近的比它大-小的数" class="headerlink" title="5.单调栈 —— 模板题 AcWing 830. 单调栈(常见模型：找出每个数左边离它最近的比它大&#x2F;小的数)"></a>5.单调栈 —— 模板题 AcWing 830. 单调栈(常见模型：找出每个数左边离它最近的比它大&#x2F;小的数)</h2><pre><code class="c++">int tt = 0;
for (int i = 1; i &lt;= n; i ++ )
&#123;
    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
&#125;
</code></pre>
<h2 id="6-单调队列-——-模板题-AcWing-154-滑动窗口-常见模型：找出滑动窗口中的最大值-最小值"><a href="#6-单调队列-——-模板题-AcWing-154-滑动窗口-常见模型：找出滑动窗口中的最大值-最小值" class="headerlink" title="6.单调队列 —— 模板题 AcWing 154. 滑动窗口(常见模型：找出滑动窗口中的最大值&#x2F;最小值)"></a>6.单调队列 —— 模板题 AcWing 154. 滑动窗口(常见模型：找出滑动窗口中的最大值&#x2F;最小值)</h2><pre><code class="c++">int hh = 0, tt = -1;
for (int i = 0; i &lt; n; i ++ )
&#123;
    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
&#125;
</code></pre>
<h2 id="7-KMP-——-模板题-AcWing-831-KMP字符串"><a href="#7-KMP-——-模板题-AcWing-831-KMP字符串" class="headerlink" title="7.KMP —— 模板题 AcWing 831. KMP字符串"></a>7.KMP —— 模板题 AcWing 831. KMP字符串</h2><pre><code class="c++">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i &lt;= m; i ++ )
&#123;
    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
&#125;

// 匹配
for (int i = 1, j = 0; i &lt;= n; i ++ )
&#123;
    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    &#123;
        j = ne[j];
        // 匹配成功后的逻辑
    &#125;
&#125;
</code></pre>
<h2 id="8-Trie树-——-模板题-AcWing-835-Trie字符串统计"><a href="#8-Trie树-——-模板题-AcWing-835-Trie字符串统计" class="headerlink" title="8.Trie树 —— 模板题 AcWing 835. Trie字符串统计"></a>8.Trie树 —— 模板题 AcWing 835. Trie字符串统计</h2><pre><code class="c++">int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
&#123;
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    &#123;
        int u = str[i] - &#39;a&#39;;
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    &#125;
    cnt[p] ++ ;
&#125;

// 查询字符串出现的次数
int query(char *str)
&#123;
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    &#123;
        int u = str[i] - &#39;a&#39;;
        if (!son[p][u]) return 0;
        p = son[p][u];
    &#125;
    return cnt[p];
&#125;
</code></pre>
<h2 id="9-并查集-——-模板题-AcWing-836-合并集合-AcWing-837-连通块中点的数量"><a href="#9-并查集-——-模板题-AcWing-836-合并集合-AcWing-837-连通块中点的数量" class="headerlink" title="9.并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量"></a>9.并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量</h2><h3 id="朴素并查集："><a href="#朴素并查集：" class="headerlink" title="朴素并查集："></a>朴素并查集：</h3><pre><code class="c++"> int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    &#123;
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    &#125;

    // 初始化，假定节点编号是1~n
    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
</code></pre>
<h3 id="维护size的并查集："><a href="#维护size的并查集：" class="headerlink" title="维护size的并查集："></a>维护size的并查集：</h3><pre><code class="c++">int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点
    int find(int x)
    &#123;
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    &#125;

    // 初始化，假定节点编号是1~n
    for (int i = 1; i &lt;= n; i ++ )
    &#123;
        p[i] = i;
        size[i] = 1;
    &#125;

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
</code></pre>
<h3 id="维护到祖宗节点距离的并查集："><a href="#维护到祖宗节点距离的并查集：" class="headerlink" title="维护到祖宗节点距离的并查集："></a>维护到祖宗节点距离的并查集：</h3><pre><code class="c++">int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

    // 返回x的祖宗节点
    int find(int x)
    &#123;
        if (p[x] != x)
        &#123;
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        &#125;
        return p[x];
    &#125;

    // 初始化，假定节点编号是1~n
    for (int i = 1; i &lt;= n; i ++ )
    &#123;
        p[i] = i;
        d[i] = 0;
    &#125;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
</code></pre>
<h2 id="10-堆-——-模板题-AcWing-838-堆排序-AcWing-839-模拟堆"><a href="#10-堆-——-模板题-AcWing-838-堆排序-AcWing-839-模拟堆" class="headerlink" title="10.堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆"></a>10.堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆</h2><pre><code class="c++">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
&#123;
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
&#125;

void down(int u)
&#123;
    int t = u;
    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;
    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;
    if (u != t)
    &#123;
        heap_swap(u, t);
        down(t);
    &#125;
&#125;

void up(int u)
&#123;
    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])
    &#123;
        heap_swap(u, u / 2);
        u &gt;&gt;= 1;
    &#125;
&#125;

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
</code></pre>
<h2 id="11-一般哈希-——-模板题-AcWing-840-模拟散列表"><a href="#11-一般哈希-——-模板题-AcWing-840-模拟散列表" class="headerlink" title="11.一般哈希 —— 模板题 AcWing 840. 模拟散列表"></a>11.一般哈希 —— 模板题 AcWing 840. 模拟散列表</h2><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><pre><code class="c++">int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    &#123;
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    &#125;

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    &#123;
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    &#125;
</code></pre>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><pre><code class="c++">int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    &#123;
        int t = (x % N + N) % N;
        while (h[t] != null &amp;&amp; h[t] != x)
        &#123;
            t ++ ;
            if (t == N) t = 0;
        &#125;
        return t;
    &#125;
</code></pre>
<h2 id="12-字符串哈希-——-模板题-AcWing-841-字符串哈希"><a href="#12-字符串哈希-——-模板题-AcWing-841-字符串哈希" class="headerlink" title="12.字符串哈希 —— 模板题 AcWing 841. 字符串哈希"></a>12.字符串哈希 —— 模板题 AcWing 841. 字符串哈希</h2><blockquote>
<p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低</p>
<p>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
</blockquote>
<pre><code class="c++">typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i &lt;= n; i ++ )
&#123;
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
&#125;

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
&#123;
    return h[r] - h[l - 1] * p[r - l + 1];
&#125;
</code></pre>
<h1 id="C-STL简介"><a href="#C-STL简介" class="headerlink" title="C++ STL简介"></a>C++ STL简介</h1><h3 id="vector-变长数组，倍增的思想"><a href="#vector-变长数组，倍增的思想" class="headerlink" title="vector, 变长数组，倍增的思想"></a>vector, 变长数组，倍增的思想</h3><blockquote>
<p> size()  返回元素个数</p>
<p>  empty()  返回是否为空</p>
<p>  clear()  清空</p>
<p>  front()&#x2F;back()</p>
<p>  push_back()&#x2F;pop_back()</p>
<p>  begin()&#x2F;end()</p>
<p>  []</p>
<p>  支持比较运算，按字典序</p>
</blockquote>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair&lt;int, int&gt;"></a>pair&lt;int, int&gt;</h3><blockquote>
<p>  first, 第一个元素</p>
<p>  second, 第二个元素</p>
<p>  支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</p>
</blockquote>
<h3 id="string，字符串"><a href="#string，字符串" class="headerlink" title="string，字符串"></a>string，字符串</h3><blockquote>
<p> size()&#x2F;length()  返回字符串长度</p>
<p>  empty()</p>
<p>  clear()</p>
<p>  substr(起始下标，(子串长度))  返回子串</p>
<p>  c_str()  返回字符串所在字符数组的起始地址</p>
</blockquote>
<p>queue, 队列</p>
<p>  size()</p>
<p>  empty()</p>
<p>  push()  向队尾插入一个元素</p>
<p>  front()  返回队头元素</p>
<p>  back()  返回队尾元素</p>
<p>  pop()  弹出队头元素</p>
<p>priority_queue, 优先队列，默认是大根堆</p>
<p>  size()</p>
<p>  empty()</p>
<p>  push()  插入一个元素</p>
<p>  top()  返回堆顶元素</p>
<p>  pop()  弹出堆顶元素</p>
<p>  定义成小根堆的方式：priority_queue&lt;int, vector<int>, greater<int>&gt; q;</p>
<p>stack, 栈</p>
<p>  size()</p>
<p>  empty()</p>
<p>  push()  向栈顶插入一个元素</p>
<p>  top()  返回栈顶元素</p>
<p>  pop()  弹出栈顶元素</p>
<p>deque, 双端队列</p>
<p>  size()</p>
<p>  empty()</p>
<p>  clear()</p>
<p>  front()&#x2F;back()</p>
<p>  push_back()&#x2F;pop_back()</p>
<p>  push_front()&#x2F;pop_front()</p>
<p>  begin()&#x2F;end()</p>
<p>  []</p>
<p>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</p>
<p>  size()</p>
<p>  empty()</p>
<p>  clear()</p>
<p>  begin()&#x2F;end()</p>
<p>  ++, – 返回前驱和后继，时间复杂度 O(logn)</p>
<p>  set&#x2F;multiset</p>
<p>​    insert()  插入一个数</p>
<p>​    find()  查找一个数</p>
<p>​    count()  返回某一个数的个数</p>
<p>​    erase()</p>
<p>​      (1) 输入是一个数x，删除所有x  O(k + logn)</p>
<p>​      (2) 输入一个迭代器，删除这个迭代器</p>
<p>​    lower_bound()&#x2F;upper_bound()</p>
<p>​      lower_bound(x)  返回大于等于x的最小的数的迭代器</p>
<p>​      upper_bound(x)  返回大于x的最小的数的迭代器</p>
<p>  map&#x2F;multimap</p>
<p>​    insert()  插入的数是一个pair</p>
<p>​    erase()  输入的参数是pair或者迭代器</p>
<p>​    find()</p>
<p>​    []  注意multimap不支持此操作。 时间复杂度是 O(logn)</p>
<p>​    lower_bound()&#x2F;upper_bound()</p>
<p>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</p>
<p>  和上面类似，增删改查的时间复杂度是 O(1)</p>
<p>  不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，–</p>
<p>bitset, 圧位</p>
<p>  bitset&lt;10000&gt; s;</p>
<p>  ~, &amp;, |, ^</p>
<p>  &gt;&gt;, &lt;&lt;</p>
<p>  &#x3D;&#x3D;, !&#x3D;</p>
<p>  []</p>
<p>  count()  返回有多少个1</p>
<p>  any()  判断是否至少有一个1</p>
<p>  none()  判断是否全为0</p>
<p>  set()  把所有位置成1</p>
<p>  set(k, v)  将第k位变成v</p>
<p>  reset()  把所有位变成0</p>
<p>  flip()  等价于~</p>
<p>flip(k) 把第k位取反</p>
<h1 id="常用代码模板3——搜索与图论"><a href="#常用代码模板3——搜索与图论" class="headerlink" title="常用代码模板3——搜索与图论"></a>常用代码模板3——搜索与图论</h1><h2 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h2><blockquote>
<p>树是一种特殊的图，与图的存储方式相同。</p>
<p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</p>
<p>因此我们可以只考虑有向图的存储。</p>
</blockquote>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 SWe1L
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Mr-SW
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="Mr-sww/Mr-sww.github.io"
    data-repo-id="R_kgDONRqd4g"
    data-category="Announcements"
    data-category-id="DIC_kwDONRqd4s4CkjmB"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





    
    <canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>
<canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
<div id="cursor"></div>
<link rel="stylesheet" href="/css/cursor.min.css" />
<script src="/js/cursor.min.js"></script>
</body>
</html>
